\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md29}{}\doxysection{Command Line}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md29}
\href{\#output-formats}{\texttt{ Output Formats}}

\href{\#output-files}{\texttt{ Output Files}}

\href{\#running-benchmarks}{\texttt{ Running Benchmarks}}

\href{\#running-a-subset-of-benchmarks}{\texttt{ Running a Subset of Benchmarks}}

\href{\#result-comparison}{\texttt{ Result Comparison}}

\href{\#extra-context}{\texttt{ Extra Context}}\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md30}{}\doxysection{Library}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md30}
\href{\#runtime-and-reporting-considerations}{\texttt{ Runtime and Reporting Considerations}}

\href{\#setupteardown}{\texttt{ Setup/\+Teardown}}

\href{\#passing-arguments}{\texttt{ Passing Arguments}}

\href{\#custom-benchmark-name}{\texttt{ Custom Benchmark Name}}

\href{\#asymptotic-complexity}{\texttt{ Calculating Asymptotic Complexity}}

\href{\#templated-benchmarks}{\texttt{ Templated Benchmarks}}

\href{\#fixtures}{\texttt{ Fixtures}}

\href{\#custom-counters}{\texttt{ Custom Counters}}

\href{\#multithreaded-benchmarks}{\texttt{ Multithreaded Benchmarks}}

\href{\#cpu-timers}{\texttt{ C\+PU Timers}}

\href{\#manual-timing}{\texttt{ Manual Timing}}

\href{\#setting-the-time-unit}{\texttt{ Setting the Time Unit}}

Random Interleaving

User-\/\+Requested Performance Counters

\href{\#preventing-optimization}{\texttt{ Preventing Optimization}}

\href{\#reporting-statistics}{\texttt{ Reporting Statistics}}

\href{\#custom-statistics}{\texttt{ Custom Statistics}}

\href{\#using-register-benchmark}{\texttt{ Using Register\+Benchmark}}

\href{\#exiting-with-an-error}{\texttt{ Exiting with an Error}}

\href{\#a-faster-keep-running-loop}{\texttt{ A Faster Keep\+Running Loop}}

\href{\#disabling-cpu-frequency-scaling}{\texttt{ Disabling C\+PU Frequency Scaling}}

\label{_output-formats}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md31}{}\doxysection{Output Formats}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md31}
The library supports multiple output formats. Use the {\ttfamily -\/-\/benchmark\+\_\+format=$<$console$\vert$json$\vert$csv$>$} flag (or set the {\ttfamily B\+E\+N\+C\+H\+M\+A\+R\+K\+\_\+\+F\+O\+R\+M\+AT=$<$console$\vert$json$\vert$csv$>$} environment variable) to set the format type. {\ttfamily console} is the default format.

The Console format is intended to be a human readable format. By default the format generates color output. Context is output on stderr and the tabular data on stdout. Example tabular output looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Benchmark                               Time(ns)    CPU(ns) Iterations}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{BM\_SetInsert/1024/1                        28928      29349      23853  133.097kB/s   33.2742k items/s}
\DoxyCodeLine{BM\_SetInsert/1024/8                        32065      32913      21375  949.487kB/s   237.372k items/s}
\DoxyCodeLine{BM\_SetInsert/1024/10                       33157      33648      21431  1.13369MB/s   290.225k items/s}
\end{DoxyCode}


The J\+S\+ON format outputs human readable json split into two top level attributes. The {\ttfamily context} attribute contains information about the run in general, including information about the C\+PU and the date. The {\ttfamily benchmarks} attribute contains a list of every benchmark run. Example json output looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{  "context": \{}
\DoxyCodeLine{    "date": "2015/03/17-\/18:40:25",}
\DoxyCodeLine{    "num\_cpus": 40,}
\DoxyCodeLine{    "mhz\_per\_cpu": 2801,}
\DoxyCodeLine{    "cpu\_scaling\_enabled": false,}
\DoxyCodeLine{    "build\_type": "debug"}
\DoxyCodeLine{  \},}
\DoxyCodeLine{  "benchmarks": [}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      "name": "BM\_SetInsert/1024/1",}
\DoxyCodeLine{      "iterations": 94877,}
\DoxyCodeLine{      "real\_time": 29275,}
\DoxyCodeLine{      "cpu\_time": 29836,}
\DoxyCodeLine{      "bytes\_per\_second": 134066,}
\DoxyCodeLine{      "items\_per\_second": 33516}
\DoxyCodeLine{    \},}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      "name": "BM\_SetInsert/1024/8",}
\DoxyCodeLine{      "iterations": 21609,}
\DoxyCodeLine{      "real\_time": 32317,}
\DoxyCodeLine{      "cpu\_time": 32429,}
\DoxyCodeLine{      "bytes\_per\_second": 986770,}
\DoxyCodeLine{      "items\_per\_second": 246693}
\DoxyCodeLine{    \},}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      "name": "BM\_SetInsert/1024/10",}
\DoxyCodeLine{      "iterations": 21393,}
\DoxyCodeLine{      "real\_time": 32724,}
\DoxyCodeLine{      "cpu\_time": 33355,}
\DoxyCodeLine{      "bytes\_per\_second": 1199226,}
\DoxyCodeLine{      "items\_per\_second": 299807}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  ]}
\DoxyCodeLine{\}}
\end{DoxyCode}


The C\+SV format outputs comma-\/separated values. The {\ttfamily context} is output on stderr and the C\+SV itself on stdout. Example C\+SV output looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{name,iterations,real\_time,cpu\_time,bytes\_per\_second,items\_per\_second,label}
\DoxyCodeLine{"BM\_SetInsert/1024/1",65465,17890.7,8407.45,475768,118942,}
\DoxyCodeLine{"BM\_SetInsert/1024/8",116606,18810.1,9766.64,3.27646e+06,819115,}
\DoxyCodeLine{"BM\_SetInsert/1024/10",106365,17238.4,8421.53,4.74973e+06,1.18743e+06,}
\end{DoxyCode}


\label{_output-files}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md32}{}\doxysection{Output Files}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md32}
Write benchmark results to a file with the {\ttfamily -\/-\/benchmark\+\_\+out=$<$filename$>$} option (or set {\ttfamily B\+E\+N\+C\+H\+M\+A\+R\+K\+\_\+\+O\+UT}). Specify the output format with {\ttfamily -\/-\/benchmark\+\_\+out\+\_\+format=\{json$\vert$console$\vert$csv\}} (or set {\ttfamily B\+E\+N\+C\+H\+M\+A\+R\+K\+\_\+\+O\+U\+T\+\_\+\+F\+O\+R\+M\+AT=\{json$\vert$console$\vert$csv\}}). Note that the \textquotesingle{}csv\textquotesingle{} reporter is deprecated and the saved {\ttfamily .csv} file \href{https://github.com/google/benchmark/issues/794}{\texttt{ is not parsable}} by csv parsers.

Specifying {\ttfamily -\/-\/benchmark\+\_\+out} does not suppress the console output.

\label{_running-benchmarks}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md33}{}\doxysection{Running Benchmarks}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md33}
Benchmarks are executed by running the produced binaries. Benchmarks binaries, by default, accept options that may be specified either through their command line interface or by setting environment variables before execution. For every {\ttfamily -\/-\/option\+\_\+flag=$<$value$>$} C\+LI switch, a corresponding environment variable {\ttfamily O\+P\+T\+I\+O\+N\+\_\+\+F\+L\+AG=$<$value$>$} exist and is used as default if set (C\+LI switches always prevails). A complete list of C\+LI options is available running benchmarks with the {\ttfamily -\/-\/help} switch.

\label{_running-a-subset-of-benchmarks}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md34}{}\doxysection{Running a Subset of Benchmarks}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md34}
The {\ttfamily -\/-\/benchmark\+\_\+filter=$<$regex$>$} option (or {\ttfamily B\+E\+N\+C\+H\+M\+A\+R\+K\+\_\+\+F\+I\+L\+T\+ER=$<$regex$>$} environment variable) can be used to only run the benchmarks that match the specified {\ttfamily $<$regex$>$}. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$ ./run\_benchmarks.x -\/-\/benchmark\_filter=BM\_memcpy/32}
\DoxyCodeLine{Run on (1 X 2300 MHz CPU )}
\DoxyCodeLine{2016-\/06-\/25 19:34:24}
\DoxyCodeLine{Benchmark              Time           CPU Iterations}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{BM\_memcpy/32          11 ns         11 ns   79545455}
\DoxyCodeLine{BM\_memcpy/32k       2181 ns       2185 ns     324074}
\DoxyCodeLine{BM\_memcpy/32          12 ns         12 ns   54687500}
\DoxyCodeLine{BM\_memcpy/32k       1834 ns       1837 ns     357143}
\end{DoxyCode}


\label{_result-comparison}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md35}{}\doxysection{Result comparison}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md35}
It is possible to compare the benchmarking results. See Additional Tooling Documentation

\label{_extra-context}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md36}{}\doxysection{Extra Context}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md36}
Sometimes it\textquotesingle{}s useful to add extra context to the content printed before the results. By default this section includes information about the C\+PU on which the benchmarks are running. If you do want to add more context, you can use the {\ttfamily benchmark\+\_\+context} command line flag\+:

\`{}\`{}{\ttfamily bash \$ ./run\+\_\+benchmarks -\/-\/benchmark\+\_\+context=pwd=}pwd\`{} Run on (1 x 2300 M\+Hz C\+PU) pwd\+: /home/user/benchmark/ \hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md37}{}\doxysection{Benchmark              Time           C\+P\+U Iterations}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md37}
B\+M\+\_\+memcpy/32 11 ns 11 ns 79545455 B\+M\+\_\+memcpy/32k 2181 ns 2185 ns 324074 
\begin{DoxyCode}{0}
\DoxyCodeLine{You can get the same effect with the API:}
\DoxyCodeLine{}
\DoxyCodeLine{```c++}
\DoxyCodeLine{  benchmark::AddCustomContext("foo", "bar");}
\end{DoxyCode}


Note that attempts to add a second value with the same key will fail with an error message.

\label{_runtime-and-reporting-considerations}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md38}{}\doxysection{Runtime and Reporting Considerations}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md38}
When the benchmark binary is executed, each benchmark function is run serially. The number of iterations to run is determined dynamically by running the benchmark a few times and measuring the time taken and ensuring that the ultimate result will be statistically stable. As such, faster benchmark functions will be run for more iterations than slower benchmark functions, and the number of iterations is thus reported.

In all cases, the number of iterations for which the benchmark is run is governed by the amount of time the benchmark takes. Concretely, the number of iterations is at least one, not more than 1e9, until C\+PU time is greater than the minimum time, or the wallclock time is 5x minimum time. The minimum time is set per benchmark by calling {\ttfamily Min\+Time} on the registered benchmark object.

Average timings are then reported over the iterations run. If multiple repetitions are requested using the {\ttfamily -\/-\/benchmark\+\_\+repetitions} command-\/line option, or at registration time, the benchmark function will be run several times and statistical results across these repetitions will also be reported.

As well as the per-\/benchmark entries, a preamble in the report will include information about the machine on which the benchmarks are run.

\label{_setup-teardown}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md39}{}\doxysection{Setup/\+Teardown}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md39}
Global setup/teardown specific to each benchmark can be done by passing a callback to Setup/\+Teardown\+:

The setup/teardown callbacks will be invoked once for each benchmark. If the benchmark is multi-\/threaded (will run in k threads), they will be invoked exactly once before each run with k threads. If the benchmark uses different size groups of threads, the above will be true for each size group.

Eg.,


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void DoSetup(const benchmark::State\& state) \{}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{static void DoTeardown(const benchmark::State\& state) \{}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{static void BM\_func(benchmark::State\& state) \{...\}}
\DoxyCodeLine{}
\DoxyCodeLine{BENCHMARK(BM\_func)-\/>Arg(1)-\/>Arg(3)-\/>Threads(16)-\/>Threads(32)-\/>Setup(DoSetup)-\/>Teardown(DoTeardown);}
\end{DoxyCode}


In this example, {\ttfamily Do\+Setup} and {\ttfamily Do\+Tear\+Down} will be invoked 4 times each, specifically, once for each of this family\+:
\begin{DoxyItemize}
\item B\+M\+\_\+func\+\_\+\+Arg\+\_\+1\+\_\+\+Threads\+\_\+16, B\+M\+\_\+func\+\_\+\+Arg\+\_\+1\+\_\+\+Threads\+\_\+32
\item B\+M\+\_\+func\+\_\+\+Arg\+\_\+3\+\_\+\+Threads\+\_\+16, B\+M\+\_\+func\+\_\+\+Arg\+\_\+3\+\_\+\+Threads\+\_\+32
\end{DoxyItemize}

\label{_passing-arguments}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md40}{}\doxysection{Passing Arguments}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md40}
Sometimes a family of benchmarks can be implemented with just one routine that takes an extra argument to specify which one of the family of benchmarks to run. For example, the following code defines a family of benchmarks for measuring the speed of {\ttfamily memcpy()} calls of different lengths\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void BM\_memcpy(benchmark::State\& state) \{}
\DoxyCodeLine{  char* src = new char[state.range(0)];}
\DoxyCodeLine{  char* dst = new char[state.range(0)];}
\DoxyCodeLine{  memset(src, 'x', state.range(0));}
\DoxyCodeLine{  for (auto \_ : state)}
\DoxyCodeLine{    memcpy(dst, src, state.range(0));}
\DoxyCodeLine{  state.SetBytesProcessed(int64\_t(state.iterations()) *}
\DoxyCodeLine{                          int64\_t(state.range(0)));}
\DoxyCodeLine{  delete[] src;}
\DoxyCodeLine{  delete[] dst;}
\DoxyCodeLine{\}}
\DoxyCodeLine{BENCHMARK(BM\_memcpy)-\/>Arg(8)-\/>Arg(64)-\/>Arg(512)-\/>Arg(1<<10)-\/>Arg(8<<10);}
\end{DoxyCode}


The preceding code is quite repetitive, and can be replaced with the following short-\/hand. The following invocation will pick a few appropriate arguments in the specified range and will generate a benchmark for each such argument.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{BENCHMARK(BM\_memcpy)-\/>Range(8, 8<<10);}
\end{DoxyCode}


By default the arguments in the range are generated in multiples of eight and the command above selects \mbox{[} 8, 64, 512, 4k, 8k \mbox{]}. In the following code the range multiplier is changed to multiples of two.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{BENCHMARK(BM\_memcpy)-\/>RangeMultiplier(2)-\/>Range(8, 8<<10);}
\end{DoxyCode}


Now arguments generated are \mbox{[} 8, 16, 32, 64, 128, 256, 512, 1024, 2k, 4k, 8k \mbox{]}.

The preceding code shows a method of defining a sparse range. The following example shows a method of defining a dense range. It is then used to benchmark the performance of {\ttfamily std\+::vector} initialization for uniformly increasing sizes.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void BM\_DenseRange(benchmark::State\& state) \{}
\DoxyCodeLine{  for(auto \_ : state) \{}
\DoxyCodeLine{    std::vector<int> v(state.range(0), state.range(0));}
\DoxyCodeLine{    benchmark::DoNotOptimize(v.data());}
\DoxyCodeLine{    benchmark::ClobberMemory();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{BENCHMARK(BM\_DenseRange)-\/>DenseRange(0, 1024, 128);}
\end{DoxyCode}


Now arguments generated are \mbox{[} 0, 128, 256, 384, 512, 640, 768, 896, 1024 \mbox{]}.

You might have a benchmark that depends on two or more inputs. For example, the following code defines a family of benchmarks for measuring the speed of set insertion.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void BM\_SetInsert(benchmark::State\& state) \{}
\DoxyCodeLine{  std::set<int> data;}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{    state.PauseTiming();}
\DoxyCodeLine{    data = ConstructRandomSet(state.range(0));}
\DoxyCodeLine{    state.ResumeTiming();}
\DoxyCodeLine{    for (int j = 0; j < state.range(1); ++j)}
\DoxyCodeLine{      data.insert(RandomNumber());}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{BENCHMARK(BM\_SetInsert)}
\DoxyCodeLine{    -\/>Args(\{1<<10, 128\})}
\DoxyCodeLine{    -\/>Args(\{2<<10, 128\})}
\DoxyCodeLine{    -\/>Args(\{4<<10, 128\})}
\DoxyCodeLine{    -\/>Args(\{8<<10, 128\})}
\DoxyCodeLine{    -\/>Args(\{1<<10, 512\})}
\DoxyCodeLine{    -\/>Args(\{2<<10, 512\})}
\DoxyCodeLine{    -\/>Args(\{4<<10, 512\})}
\DoxyCodeLine{    -\/>Args(\{8<<10, 512\});}
\end{DoxyCode}


The preceding code is quite repetitive, and can be replaced with the following short-\/hand. The following macro will pick a few appropriate arguments in the product of the two specified ranges and will generate a benchmark for each such pair.

\{\% raw \%\} 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{BENCHMARK(BM\_SetInsert)-\/>Ranges(\{\{1<<10, 8<<10\}, \{128, 512\}\});}
\end{DoxyCode}


\{\% endraw \%\}

Some benchmarks may require specific argument values that cannot be expressed with {\ttfamily Ranges}. In this case, {\ttfamily Args\+Product} offers the ability to generate a benchmark input for each combination in the product of the supplied vectors.

\{\% raw \%\} 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{BENCHMARK(BM\_SetInsert)}
\DoxyCodeLine{    -\/>ArgsProduct(\{\{1<<10, 3<<10, 8<<10\}, \{20, 40, 60, 80\}\})}
\DoxyCodeLine{// would generate the same benchmark arguments as}
\DoxyCodeLine{BENCHMARK(BM\_SetInsert)}
\DoxyCodeLine{    -\/>Args(\{1<<10, 20\})}
\DoxyCodeLine{    -\/>Args(\{3<<10, 20\})}
\DoxyCodeLine{    -\/>Args(\{8<<10, 20\})}
\DoxyCodeLine{    -\/>Args(\{3<<10, 40\})}
\DoxyCodeLine{    -\/>Args(\{8<<10, 40\})}
\DoxyCodeLine{    -\/>Args(\{1<<10, 40\})}
\DoxyCodeLine{    -\/>Args(\{1<<10, 60\})}
\DoxyCodeLine{    -\/>Args(\{3<<10, 60\})}
\DoxyCodeLine{    -\/>Args(\{8<<10, 60\})}
\DoxyCodeLine{    -\/>Args(\{1<<10, 80\})}
\DoxyCodeLine{    -\/>Args(\{3<<10, 80\})}
\DoxyCodeLine{    -\/>Args(\{8<<10, 80\});}
\end{DoxyCode}


\{\% endraw \%\}

For the most common scenarios, helper methods for creating a list of integers for a given sparse or dense range are provided.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{BENCHMARK(BM\_SetInsert)}
\DoxyCodeLine{    -\/>ArgsProduct(\{}
\DoxyCodeLine{      benchmark::CreateRange(8, 128, /*multi=*/2),}
\DoxyCodeLine{      benchmark::CreateDenseRange(1, 4, /*step=*/1)}
\DoxyCodeLine{    \})}
\DoxyCodeLine{// would generate the same benchmark arguments as}
\DoxyCodeLine{BENCHMARK(BM\_SetInsert)}
\DoxyCodeLine{    -\/>ArgsProduct(\{}
\DoxyCodeLine{      \{8, 16, 32, 64, 128\},}
\DoxyCodeLine{      \{1, 2, 3, 4\}}
\DoxyCodeLine{    \});}
\end{DoxyCode}


For more complex patterns of inputs, passing a custom function to {\ttfamily Apply} allows programmatic specification of an arbitrary set of arguments on which to run the benchmark. The following example enumerates a dense range on one parameter, and a sparse range on the second.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void CustomArguments(benchmark::internal::Benchmark* b) \{}
\DoxyCodeLine{  for (int i = 0; i <= 10; ++i)}
\DoxyCodeLine{    for (int j = 32; j <= 1024*1024; j *= 8)}
\DoxyCodeLine{      b-\/>Args(\{i, j\});}
\DoxyCodeLine{\}}
\DoxyCodeLine{BENCHMARK(BM\_SetInsert)-\/>Apply(CustomArguments);}
\end{DoxyCode}
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md41}{}\doxysubsection{Passing Arbitrary Arguments to a Benchmark}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md41}
In C++11 it is possible to define a benchmark that takes an arbitrary number of extra arguments. The {\ttfamily B\+E\+N\+C\+H\+M\+A\+R\+K\+\_\+\+C\+A\+P\+T\+U\+R\+E(func, test\+\_\+case\+\_\+name, ...\+args)} macro creates a benchmark that invokes {\ttfamily func} with the {\ttfamily \mbox{\hyperlink{classbenchmark_1_1State}{benchmark\+::\+State}}} as the first argument followed by the specified {\ttfamily args...}. The {\ttfamily test\+\_\+case\+\_\+name} is appended to the name of the benchmark and should describe the values passed.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{template <class ...ExtraArgs>}
\DoxyCodeLine{void BM\_takes\_args(benchmark::State\& state, ExtraArgs\&\&... extra\_args) \{}
\DoxyCodeLine{  [...]}
\DoxyCodeLine{\}}
\DoxyCodeLine{// Registers a benchmark named "BM\_takes\_args/int\_string\_test" that passes}
\DoxyCodeLine{// the specified values to `extra\_args`.}
\DoxyCodeLine{BENCHMARK\_CAPTURE(BM\_takes\_args, int\_string\_test, 42, std::string("abc"));}
\end{DoxyCode}


Note that elements of {\ttfamily ...args} may refer to global variables. Users should avoid modifying global state inside of a benchmark.

\label{_asymptotic-complexity}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md42}{}\doxysection{Calculating Asymptotic Complexity (\+Big O)}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md42}
Asymptotic complexity might be calculated for a family of benchmarks. The following code will calculate the coefficient for the high-\/order term in the running time and the normalized root-\/mean square error of string comparison.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void BM\_StringCompare(benchmark::State\& state) \{}
\DoxyCodeLine{  std::string s1(state.range(0), '-\/');}
\DoxyCodeLine{  std::string s2(state.range(0), '-\/');}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{    benchmark::DoNotOptimize(s1.compare(s2));}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  state.SetComplexityN(state.range(0));}
\DoxyCodeLine{\}}
\DoxyCodeLine{BENCHMARK(BM\_StringCompare)}
\DoxyCodeLine{    -\/>RangeMultiplier(2)-\/>Range(1<<10, 1<<18)-\/>Complexity(benchmark::oN);}
\end{DoxyCode}


As shown in the following invocation, asymptotic complexity might also be calculated automatically.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{BENCHMARK(BM\_StringCompare)}
\DoxyCodeLine{    -\/>RangeMultiplier(2)-\/>Range(1<<10, 1<<18)-\/>Complexity();}
\end{DoxyCode}


The following code will specify asymptotic complexity with a lambda function, that might be used to customize high-\/order term calculation.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{BENCHMARK(BM\_StringCompare)-\/>RangeMultiplier(2)}
\DoxyCodeLine{    -\/>Range(1<<10, 1<<18)-\/>Complexity([](benchmark::IterationCount n)-\/>double\{return n; \});}
\end{DoxyCode}


\label{_custom-benchmark-name}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md43}{}\doxysection{Custom Benchmark Name}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md43}
You can change the benchmark\textquotesingle{}s name as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{BENCHMARK(BM\_memcpy)-\/>Name("memcpy")-\/>RangeMultiplier(2)-\/>Range(8, 8<<10);}
\end{DoxyCode}


The invocation will execute the benchmark as before using {\ttfamily B\+M\+\_\+memcpy} but changes the prefix in the report to {\ttfamily memcpy}.

\label{_templated-benchmarks}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md44}{}\doxysection{Templated Benchmarks}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md44}
This example produces and consumes messages of size {\ttfamily sizeof(v)} {\ttfamily range\+\_\+x} times. It also outputs throughput in the absence of multiprogramming.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{template <class Q> void BM\_Sequential(benchmark::State\& state) \{}
\DoxyCodeLine{  Q q;}
\DoxyCodeLine{  typename Q::value\_type v;}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{    for (int i = state.range(0); i-\/-\/; )}
\DoxyCodeLine{      q.push(v);}
\DoxyCodeLine{    for (int e = state.range(0); e-\/-\/; )}
\DoxyCodeLine{      q.Wait(\&v);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  // actually messages, not bytes:}
\DoxyCodeLine{  state.SetBytesProcessed(}
\DoxyCodeLine{      static\_cast<int64\_t>(state.iterations())*state.range(0));}
\DoxyCodeLine{\}}
\DoxyCodeLine{// C++03}
\DoxyCodeLine{BENCHMARK\_TEMPLATE(BM\_Sequential, WaitQueue<int>)-\/>Range(1<<0, 1<<10);}
\DoxyCodeLine{}
\DoxyCodeLine{// C++11 or newer, you can use the BENCHMARK macro with template parameters:}
\DoxyCodeLine{BENCHMARK(BM\_Sequential<WaitQueue<int>>)-\/>Range(1<<0, 1<<10);}
\end{DoxyCode}


Three macros are provided for adding benchmark templates.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{\#ifdef BENCHMARK\_HAS\_CXX11}
\DoxyCodeLine{\#define BENCHMARK(func<...>) // Takes any number of parameters.}
\DoxyCodeLine{\#else // C++ < C++11}
\DoxyCodeLine{\#define BENCHMARK\_TEMPLATE(func, arg1)}
\DoxyCodeLine{\#endif}
\DoxyCodeLine{\#define BENCHMARK\_TEMPLATE1(func, arg1)}
\DoxyCodeLine{\#define BENCHMARK\_TEMPLATE2(func, arg1, arg2)}
\end{DoxyCode}


\label{_fixtures}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md45}{}\doxysection{Fixtures}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md45}
Fixture tests are created by first defining a type that derives from {\ttfamily \mbox{\hyperlink{classbenchmark_1_1Fixture}{benchmark\+::\+Fixture}}} and then creating/registering the tests using the following macros\+:


\begin{DoxyItemize}
\item {\ttfamily B\+E\+N\+C\+H\+M\+A\+R\+K\+\_\+\+F(\+Class\+Name, Method)}
\item {\ttfamily B\+E\+N\+C\+H\+M\+A\+R\+K\+\_\+\+D\+E\+F\+I\+N\+E\+\_\+\+F(\+Class\+Name, Method)}
\item {\ttfamily B\+E\+N\+C\+H\+M\+A\+R\+K\+\_\+\+R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+F(\+Class\+Name, Method)}
\end{DoxyItemize}

For Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{class MyFixture : public benchmark::Fixture \{}
\DoxyCodeLine{public:}
\DoxyCodeLine{  void SetUp(const ::benchmark::State\& state) \{}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  void TearDown(const ::benchmark::State\& state) \{}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{BENCHMARK\_F(MyFixture, FooTest)(benchmark::State\& st) \{}
\DoxyCodeLine{   for (auto \_ : st) \{}
\DoxyCodeLine{     ...}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{BENCHMARK\_DEFINE\_F(MyFixture, BarTest)(benchmark::State\& st) \{}
\DoxyCodeLine{   for (auto \_ : st) \{}
\DoxyCodeLine{     ...}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{/* BarTest is NOT registered */}
\DoxyCodeLine{BENCHMARK\_REGISTER\_F(MyFixture, BarTest)-\/>Threads(2);}
\DoxyCodeLine{/* BarTest is now registered */}
\end{DoxyCode}
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md46}{}\doxysubsection{Templated Fixtures}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md46}
Also you can create templated fixture by using the following macros\+:


\begin{DoxyItemize}
\item {\ttfamily B\+E\+N\+C\+H\+M\+A\+R\+K\+\_\+\+T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+F(\+Class\+Name, Method, ...)}
\item {\ttfamily B\+E\+N\+C\+H\+M\+A\+R\+K\+\_\+\+T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+D\+E\+F\+I\+N\+E\+\_\+\+F(\+Class\+Name, Method, ...)}
\end{DoxyItemize}

For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{template<typename T>}
\DoxyCodeLine{class MyFixture : public benchmark::Fixture \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{BENCHMARK\_TEMPLATE\_F(MyFixture, IntTest, int)(benchmark::State\& st) \{}
\DoxyCodeLine{   for (auto \_ : st) \{}
\DoxyCodeLine{     ...}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{BENCHMARK\_TEMPLATE\_DEFINE\_F(MyFixture, DoubleTest, double)(benchmark::State\& st) \{}
\DoxyCodeLine{   for (auto \_ : st) \{}
\DoxyCodeLine{     ...}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{BENCHMARK\_REGISTER\_F(MyFixture, DoubleTest)-\/>Threads(2);}
\end{DoxyCode}


\label{_custom-counters}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md47}{}\doxysection{Custom Counters}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md47}
You can add your own counters with user-\/defined names. The example below will add columns \char`\"{}\+Foo\char`\"{}, \char`\"{}\+Bar\char`\"{} and \char`\"{}\+Baz\char`\"{} in its output\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void UserCountersExample1(benchmark::State\& state) \{}
\DoxyCodeLine{  double numFoos = 0, numBars = 0, numBazs = 0;}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{    // ... count Foo,Bar,Baz events}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  state.counters["Foo"] = numFoos;}
\DoxyCodeLine{  state.counters["Bar"] = numBars;}
\DoxyCodeLine{  state.counters["Baz"] = numBazs;}
\DoxyCodeLine{\}}
\end{DoxyCode}


The {\ttfamily state.\+counters} object is a {\ttfamily std\+::map} with {\ttfamily std\+::string} keys and {\ttfamily \mbox{\hyperlink{classCounter}{Counter}}} values. The latter is a {\ttfamily double}-\/like class, via an implicit conversion to {\ttfamily double\&}. Thus you can use all of the standard arithmetic assignment operators ({\ttfamily =,+=,-\/=,$\ast$=,/=}) to change the value of each counter.

In multithreaded benchmarks, each counter is set on the calling thread only. When the benchmark finishes, the counters from each thread will be summed; the resulting sum is the value which will be shown for the benchmark.

The {\ttfamily \mbox{\hyperlink{classCounter}{Counter}}} constructor accepts three parameters\+: the value as a {\ttfamily double} ; a bit flag which allows you to show counters as rates, and/or as per-\/thread iteration, and/or as per-\/thread averages, and/or iteration invariants, and/or finally inverting the result; and a flag specifying the \textquotesingle{}unit\textquotesingle{} -\/ i.\+e. is 1k a 1000 (default, {\ttfamily benchmark\+::\+Counter\+::\+One\+K\+::k\+Is1000}), or 1024 ({\ttfamily benchmark\+::\+Counter\+::\+One\+K\+::k\+Is1024})?


\begin{DoxyCode}{0}
\DoxyCodeLine{\{c++\}}
\DoxyCodeLine{ // sets a simple counter}
\DoxyCodeLine{ state.counters["Foo"] = numFoos;}
\DoxyCodeLine{}
\DoxyCodeLine{ // Set the counter as a rate. It will be presented divided}
\DoxyCodeLine{ // by the duration of the benchmark.}
\DoxyCodeLine{ // Meaning: per one second, how many 'foo's are processed?}
\DoxyCodeLine{ state.counters["FooRate"] = Counter(numFoos, benchmark::Counter::kIsRate);}
\DoxyCodeLine{}
\DoxyCodeLine{ // Set the counter as a rate. It will be presented divided}
\DoxyCodeLine{ // by the duration of the benchmark, and the result inverted.}
\DoxyCodeLine{ // Meaning: how many seconds it takes to process one 'foo'?}
\DoxyCodeLine{ state.counters["FooInvRate"] = Counter(numFoos, benchmark::Counter::kIsRate | benchmark::Counter::kInvert);}
\DoxyCodeLine{}
\DoxyCodeLine{ // Set the counter as a thread-\/average quantity. It will}
\DoxyCodeLine{ // be presented divided by the number of threads.}
\DoxyCodeLine{ state.counters["FooAvg"] = Counter(numFoos, benchmark::Counter::kAvgThreads);}
\DoxyCodeLine{}
\DoxyCodeLine{ // There's also a combined flag:}
\DoxyCodeLine{ state.counters["FooAvgRate"] = Counter(numFoos,benchmark::Counter::kAvgThreadsRate);}
\DoxyCodeLine{}
\DoxyCodeLine{ // This says that we process with the rate of state.range(0) bytes every iteration:}
\DoxyCodeLine{ state.counters["BytesProcessed"] = Counter(state.range(0), benchmark::Counter::kIsIterationInvariantRate, benchmark::Counter::OneK::kIs1024);}
\end{DoxyCode}


When you\textquotesingle{}re compiling in C++11 mode or later you can use {\ttfamily insert()} with {\ttfamily std\+::initializer\+\_\+list}\+:

\{\% raw \%\} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\{c++\}}
\DoxyCodeLine{ // With C++11, this can be done:}
\DoxyCodeLine{ state.counters.insert(\{\{"Foo", numFoos\}, \{"Bar", numBars\}, \{"Baz", numBazs\}\});}
\DoxyCodeLine{ // ... instead of:}
\DoxyCodeLine{ state.counters["Foo"] = numFoos;}
\DoxyCodeLine{ state.counters["Bar"] = numBars;}
\DoxyCodeLine{ state.counters["Baz"] = numBazs;}
\end{DoxyCode}


\{\% endraw \%\}\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md48}{}\doxysubsection{Counter Reporting}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md48}
When using the console reporter, by default, user counters are printed at the end after the table, the same way as {\ttfamily bytes\+\_\+processed} and {\ttfamily items\+\_\+processed}. This is best for cases in which there are few counters, or where there are only a couple of lines per benchmark. Here\textquotesingle{}s an example of the default output\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{Benchmark                        Time           CPU Iterations UserCounters...}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{BM\_UserCounter/threads:8      2248 ns      10277 ns      68808 Bar=16 Bat=40 Baz=24 Foo=8}
\DoxyCodeLine{BM\_UserCounter/threads:1      9797 ns       9788 ns      71523 Bar=2 Bat=5 Baz=3 Foo=1024m}
\DoxyCodeLine{BM\_UserCounter/threads:2      4924 ns       9842 ns      71036 Bar=4 Bat=10 Baz=6 Foo=2}
\DoxyCodeLine{BM\_UserCounter/threads:4      2589 ns      10284 ns      68012 Bar=8 Bat=20 Baz=12 Foo=4}
\DoxyCodeLine{BM\_UserCounter/threads:8      2212 ns      10287 ns      68040 Bar=16 Bat=40 Baz=24 Foo=8}
\DoxyCodeLine{BM\_UserCounter/threads:16     1782 ns      10278 ns      68144 Bar=32 Bat=80 Baz=48 Foo=16}
\DoxyCodeLine{BM\_UserCounter/threads:32     1291 ns      10296 ns      68256 Bar=64 Bat=160 Baz=96 Foo=32}
\DoxyCodeLine{BM\_UserCounter/threads:4      2615 ns      10307 ns      68040 Bar=8 Bat=20 Baz=12 Foo=4}
\DoxyCodeLine{BM\_Factorial                    26 ns         26 ns   26608979 40320}
\DoxyCodeLine{BM\_Factorial/real\_time          26 ns         26 ns   26587936 40320}
\DoxyCodeLine{BM\_CalculatePiRange/1           16 ns         16 ns   45704255 0}
\DoxyCodeLine{BM\_CalculatePiRange/8           73 ns         73 ns    9520927 3.28374}
\DoxyCodeLine{BM\_CalculatePiRange/64         609 ns        609 ns    1140647 3.15746}
\DoxyCodeLine{BM\_CalculatePiRange/512       4900 ns       4901 ns     142696 3.14355}
\end{DoxyCode}


If this doesn\textquotesingle{}t suit you, you can print each counter as a table column by passing the flag {\ttfamily -\/-\/benchmark\+\_\+counters\+\_\+tabular=true} to the benchmark application. This is best for cases in which there are a lot of counters, or a lot of lines per individual benchmark. Note that this will trigger a reprinting of the table header any time the counter set changes between individual benchmarks. Here\textquotesingle{}s an example of corresponding output when {\ttfamily -\/-\/benchmark\+\_\+counters\+\_\+tabular=true} is passed\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{Benchmark                        Time           CPU Iterations    Bar   Bat   Baz   Foo}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{BM\_UserCounter/threads:8      2198 ns       9953 ns      70688     16    40    24     8}
\DoxyCodeLine{BM\_UserCounter/threads:1      9504 ns       9504 ns      73787      2     5     3     1}
\DoxyCodeLine{BM\_UserCounter/threads:2      4775 ns       9550 ns      72606      4    10     6     2}
\DoxyCodeLine{BM\_UserCounter/threads:4      2508 ns       9951 ns      70332      8    20    12     4}
\DoxyCodeLine{BM\_UserCounter/threads:8      2055 ns       9933 ns      70344     16    40    24     8}
\DoxyCodeLine{BM\_UserCounter/threads:16     1610 ns       9946 ns      70720     32    80    48    16}
\DoxyCodeLine{BM\_UserCounter/threads:32     1192 ns       9948 ns      70496     64   160    96    32}
\DoxyCodeLine{BM\_UserCounter/threads:4      2506 ns       9949 ns      70332      8    20    12     4}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{Benchmark                        Time           CPU Iterations}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{BM\_Factorial                    26 ns         26 ns   26392245 40320}
\DoxyCodeLine{BM\_Factorial/real\_time          26 ns         26 ns   26494107 40320}
\DoxyCodeLine{BM\_CalculatePiRange/1           15 ns         15 ns   45571597 0}
\DoxyCodeLine{BM\_CalculatePiRange/8           74 ns         74 ns    9450212 3.28374}
\DoxyCodeLine{BM\_CalculatePiRange/64         595 ns        595 ns    1173901 3.15746}
\DoxyCodeLine{BM\_CalculatePiRange/512       4752 ns       4752 ns     147380 3.14355}
\DoxyCodeLine{BM\_CalculatePiRange/4k       37970 ns      37972 ns      18453 3.14184}
\DoxyCodeLine{BM\_CalculatePiRange/32k     303733 ns     303744 ns       2305 3.14162}
\DoxyCodeLine{BM\_CalculatePiRange/256k   2434095 ns    2434186 ns        288 3.1416}
\DoxyCodeLine{BM\_CalculatePiRange/1024k  9721140 ns    9721413 ns         71 3.14159}
\DoxyCodeLine{BM\_CalculatePi/threads:8      2255 ns       9943 ns      70936}
\end{DoxyCode}


Note above the additional header printed when the benchmark changes from {\ttfamily B\+M\+\_\+\+User\+Counter} to {\ttfamily B\+M\+\_\+\+Factorial}. This is because {\ttfamily B\+M\+\_\+\+Factorial} does not have the same counter set as {\ttfamily B\+M\+\_\+\+User\+Counter}.

\label{_multithreaded-benchmarks}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md49}{}\doxysection{Multithreaded Benchmarks}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md49}
In a multithreaded test (benchmark invoked by multiple threads simultaneously), it is guaranteed that none of the threads will start until all have reached the start of the benchmark loop, and all will have finished before any thread exits the benchmark loop. (This behavior is also provided by the {\ttfamily Keep\+Running()} A\+PI) As such, any global setup or teardown can be wrapped in a check against the thread index\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void BM\_MultiThreaded(benchmark::State\& state) \{}
\DoxyCodeLine{  if (state.thread\_index() == 0) \{}
\DoxyCodeLine{    // Setup code here.}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{    // Run the test as normal.}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  if (state.thread\_index() == 0) \{}
\DoxyCodeLine{    // Teardown code here.}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{BENCHMARK(BM\_MultiThreaded)-\/>Threads(2);}
\end{DoxyCode}


If the benchmarked code itself uses threads and you want to compare it to single-\/threaded code, you may want to use real-\/time (\char`\"{}wallclock\char`\"{}) measurements for latency comparisons\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{BENCHMARK(BM\_test)-\/>Range(8, 8<<10)-\/>UseRealTime();}
\end{DoxyCode}


Without {\ttfamily Use\+Real\+Time}, C\+PU time is used by default.

\label{_cpu-timers}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md50}{}\doxysection{C\+P\+U Timers}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md50}
By default, the C\+PU timer only measures the time spent by the main thread. If the benchmark itself uses threads internally, this measurement may not be what you are looking for. Instead, there is a way to measure the total C\+PU usage of the process, by all the threads.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{void callee(int i);}
\DoxyCodeLine{}
\DoxyCodeLine{static void MyMain(int size) \{}
\DoxyCodeLine{\#pragma omp parallel for}
\DoxyCodeLine{  for(int i = 0; i < size; i++)}
\DoxyCodeLine{    callee(i);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{static void BM\_OpenMP(benchmark::State\& state) \{}
\DoxyCodeLine{  for (auto \_ : state)}
\DoxyCodeLine{    MyMain(state.range(0));}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{// Measure the time spent by the main thread, use it to decide for how long to}
\DoxyCodeLine{// run the benchmark loop. Depending on the internal implementation detail may}
\DoxyCodeLine{// measure to anywhere from near-\/zero (the overhead spent before/after work}
\DoxyCodeLine{// handoff to worker thread[s]) to the whole single-\/thread time.}
\DoxyCodeLine{BENCHMARK(BM\_OpenMP)-\/>Range(8, 8<<10);}
\DoxyCodeLine{}
\DoxyCodeLine{// Measure the user-\/visible time, the wall clock (literally, the time that}
\DoxyCodeLine{// has passed on the clock on the wall), use it to decide for how long to}
\DoxyCodeLine{// run the benchmark loop. This will always be meaningful, an will match the}
\DoxyCodeLine{// time spent by the main thread in single-\/threaded case, in general decreasing}
\DoxyCodeLine{// with the number of internal threads doing the work.}
\DoxyCodeLine{BENCHMARK(BM\_OpenMP)-\/>Range(8, 8<<10)-\/>UseRealTime();}
\DoxyCodeLine{}
\DoxyCodeLine{// Measure the total CPU consumption, use it to decide for how long to}
\DoxyCodeLine{// run the benchmark loop. This will always measure to no less than the}
\DoxyCodeLine{// time spent by the main thread in single-\/threaded case.}
\DoxyCodeLine{BENCHMARK(BM\_OpenMP)-\/>Range(8, 8<<10)-\/>MeasureProcessCPUTime();}
\DoxyCodeLine{}
\DoxyCodeLine{// A mixture of the last two. Measure the total CPU consumption, but use the}
\DoxyCodeLine{// wall clock to decide for how long to run the benchmark loop.}
\DoxyCodeLine{BENCHMARK(BM\_OpenMP)-\/>Range(8, 8<<10)-\/>MeasureProcessCPUTime()-\/>UseRealTime();}
\end{DoxyCode}
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md51}{}\doxysubsection{Controlling Timers}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md51}
Normally, the entire duration of the work loop ({\ttfamily for (auto \+\_\+ \+: state) \{\}}) is measured. But sometimes, it is necessary to do some work inside of that loop, every iteration, but without counting that time to the benchmark time. That is possible, although it is not recommended, since it has high overhead.

\{\% raw \%\} 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void BM\_SetInsert\_With\_Timer\_Control(benchmark::State\& state) \{}
\DoxyCodeLine{  std::set<int> data;}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{    state.PauseTiming(); // Stop timers. They will not count until they are resumed.}
\DoxyCodeLine{    data = ConstructRandomSet(state.range(0)); // Do something that should not be measured}
\DoxyCodeLine{    state.ResumeTiming(); // And resume timers. They are now counting again.}
\DoxyCodeLine{    // The rest will be measured.}
\DoxyCodeLine{    for (int j = 0; j < state.range(1); ++j)}
\DoxyCodeLine{      data.insert(RandomNumber());}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{BENCHMARK(BM\_SetInsert\_With\_Timer\_Control)-\/>Ranges(\{\{1<<10, 8<<10\}, \{128, 512\}\});}
\end{DoxyCode}


\{\% endraw \%\}

\label{_manual-timing}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md52}{}\doxysection{Manual Timing}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md52}
For benchmarking something for which neither C\+PU time nor real-\/time are correct or accurate enough, completely manual timing is supported using the {\ttfamily Use\+Manual\+Time} function.

When {\ttfamily Use\+Manual\+Time} is used, the benchmarked code must call {\ttfamily Set\+Iteration\+Time} once per iteration of the benchmark loop to report the manually measured time.

An example use case for this is benchmarking G\+PU execution (e.\+g. Open\+CL or C\+U\+DA kernels, Open\+GL or Vulkan or Direct3D draw calls), which cannot be accurately measured using C\+PU time or real-\/time. Instead, they can be measured accurately using a dedicated A\+PI, and these measurement results can be reported back with {\ttfamily Set\+Iteration\+Time}.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void BM\_ManualTiming(benchmark::State\& state) \{}
\DoxyCodeLine{  int microseconds = state.range(0);}
\DoxyCodeLine{  std::chrono::duration<double, std::micro> sleep\_duration \{}
\DoxyCodeLine{    static\_cast<double>(microseconds)}
\DoxyCodeLine{  \};}
\DoxyCodeLine{}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{    auto start = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{    // Simulate some useful workload with a sleep}
\DoxyCodeLine{    std::this\_thread::sleep\_for(sleep\_duration);}
\DoxyCodeLine{    auto end = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{}
\DoxyCodeLine{    auto elapsed\_seconds =}
\DoxyCodeLine{      std::chrono::duration\_cast<std::chrono::duration<double>>(}
\DoxyCodeLine{        end -\/ start);}
\DoxyCodeLine{}
\DoxyCodeLine{    state.SetIterationTime(elapsed\_seconds.count());}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{BENCHMARK(BM\_ManualTiming)-\/>Range(1, 1<<17)-\/>UseManualTime();}
\end{DoxyCode}


\label{_setting-the-time-unit}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md53}{}\doxysection{Setting the Time Unit}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md53}
If a benchmark runs a few milliseconds it may be hard to visually compare the measured times, since the output data is given in nanoseconds per default. In order to manually set the time unit, you can specify it manually\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{BENCHMARK(BM\_test)-\/>Unit(benchmark::kMillisecond);}
\end{DoxyCode}


\label{_preventing-optimization}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md54}{}\doxysection{Preventing Optimization}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md54}
To prevent a value or expression from being optimized away by the compiler the {\ttfamily benchmark\+::\+Do\+Not\+Optimize(...)} and {\ttfamily benchmark\+::\+Clobber\+Memory()} functions can be used.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void BM\_test(benchmark::State\& state) \{}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{      int x = 0;}
\DoxyCodeLine{      for (int i=0; i < 64; ++i) \{}
\DoxyCodeLine{        benchmark::DoNotOptimize(x += i);}
\DoxyCodeLine{      \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\end{DoxyCode}


{\ttfamily Do\+Not\+Optimize($<$expr$>$)} forces the {\itshape result} of {\ttfamily $<$expr$>$} to be stored in either memory or a register. For G\+NU based compilers it acts as read/write barrier for global memory. More specifically it forces the compiler to flush pending writes to memory and reload any other values as necessary.

Note that {\ttfamily Do\+Not\+Optimize($<$expr$>$)} does not prevent optimizations on {\ttfamily $<$expr$>$} in any way. {\ttfamily $<$expr$>$} may even be removed entirely when the result is already known. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{c++\}}
\DoxyCodeLine{ /* Example 1: `<expr>` is removed entirely. */}
\DoxyCodeLine{ int foo(int x) \{ return x + 42; \}}
\DoxyCodeLine{ while (...) DoNotOptimize(foo(0)); // Optimized to DoNotOptimize(42);}
\DoxyCodeLine{}
\DoxyCodeLine{ /*  Example 2: Result of '<expr>' is only reused */}
\DoxyCodeLine{ int bar(int) \_\_attribute\_\_((const));}
\DoxyCodeLine{ while (...) DoNotOptimize(bar(0)); // Optimized to:}
\DoxyCodeLine{ // int \_\_result\_\_ = bar(0);}
\DoxyCodeLine{ // while (...) DoNotOptimize(\_\_result\_\_);}
\end{DoxyCode}


The second tool for preventing optimizations is {\ttfamily Clobber\+Memory()}. In essence {\ttfamily Clobber\+Memory()} forces the compiler to perform all pending writes to global memory. Memory managed by block scope objects must be \char`\"{}escaped\char`\"{} using {\ttfamily Do\+Not\+Optimize(...)} before it can be clobbered. In the below example {\ttfamily Clobber\+Memory()} prevents the call to {\ttfamily v.\+push\+\_\+back(42)} from being optimized away.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void BM\_vector\_push\_back(benchmark::State\& state) \{}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{    std::vector<int> v;}
\DoxyCodeLine{    v.reserve(1);}
\DoxyCodeLine{    benchmark::DoNotOptimize(v.data()); // Allow v.data() to be clobbered.}
\DoxyCodeLine{    v.push\_back(42);}
\DoxyCodeLine{    benchmark::ClobberMemory(); // Force 42 to be written to memory.}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\end{DoxyCode}


Note that {\ttfamily Clobber\+Memory()} is only available for G\+NU or M\+S\+VC based compilers.

\label{_reporting-statistics}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md55}{}\doxysection{Statistics\+: Reporting the Mean, Median and Standard Deviation / Coefficient of variation of Repeated Benchmarks}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md55}
By default each benchmark is run once and that single result is reported. However benchmarks are often noisy and a single result may not be representative of the overall behavior. For this reason it\textquotesingle{}s possible to repeatedly rerun the benchmark.

The number of runs of each benchmark is specified globally by the {\ttfamily -\/-\/benchmark\+\_\+repetitions} flag or on a per benchmark basis by calling {\ttfamily Repetitions} on the registered benchmark object. When a benchmark is run more than once the mean, median, standard deviation and coefficient of variation of the runs will be reported.

Additionally the {\ttfamily -\/-\/benchmark\+\_\+report\+\_\+aggregates\+\_\+only=\{true$\vert$false\}}, {\ttfamily -\/-\/benchmark\+\_\+display\+\_\+aggregates\+\_\+only=\{true$\vert$false\}} flags or {\ttfamily Report\+Aggregates\+Only(bool)}, {\ttfamily Display\+Aggregates\+Only(bool)} functions can be used to change how repeated tests are reported. By default the result of each repeated run is reported. When {\ttfamily report aggregates only} option is {\ttfamily true}, only the aggregates (i.\+e. mean, median, standard deviation and coefficient of variation, maybe complexity measurements if they were requested) of the runs is reported, to both the reporters -\/ standard output (console), and the file. However when only the {\ttfamily display aggregates only} option is {\ttfamily true}, only the aggregates are displayed in the standard output, while the file output still contains everything. Calling {\ttfamily Report\+Aggregates\+Only(bool)} / {\ttfamily Display\+Aggregates\+Only(bool)} on a registered benchmark object overrides the value of the appropriate flag for that benchmark.

\label{_custom-statistics}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md56}{}\doxysection{Custom Statistics}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md56}
While having these aggregates is nice, this may not be enough for everyone. For example you may want to know what the largest observation is, e.\+g. because you have some real-\/time constraints. This is easy. The following code will specify a custom statistic to be calculated, defined by a lambda function.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{void BM\_spin\_empty(benchmark::State\& state) \{}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{    for (int x = 0; x < state.range(0); ++x) \{}
\DoxyCodeLine{      benchmark::DoNotOptimize(x);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{BENCHMARK(BM\_spin\_empty)}
\DoxyCodeLine{  -\/>ComputeStatistics("max", [](const std::vector<double>\& v) -\/> double \{}
\DoxyCodeLine{    return *(std::max\_element(std::begin(v), std::end(v)));}
\DoxyCodeLine{  \})}
\DoxyCodeLine{  -\/>Arg(512);}
\end{DoxyCode}


While usually the statistics produce values in time units, you can also produce percentages\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{void BM\_spin\_empty(benchmark::State\& state) \{}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{    for (int x = 0; x < state.range(0); ++x) \{}
\DoxyCodeLine{      benchmark::DoNotOptimize(x);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{BENCHMARK(BM\_spin\_empty)}
\DoxyCodeLine{  -\/>ComputeStatistics("ratio", [](const std::vector<double>\& v) -\/> double \{}
\DoxyCodeLine{    return std::begin(v) / std::end(v);}
\DoxyCodeLine{  \}, benchmark::StatisticUnit::Percentage)}
\DoxyCodeLine{  -\/>Arg(512);}
\end{DoxyCode}


\label{_using-register-benchmark}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md57}{}\doxysection{Using Register\+Benchmark(name, fn, args...)}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md57}
The {\ttfamily Register\+Benchmark(name, func, args...)} function provides an alternative way to create and register benchmarks. {\ttfamily Register\+Benchmark(name, func, args...)} creates, registers, and returns a pointer to a new benchmark with the specified {\ttfamily name} that invokes {\ttfamily func(st, args...)} where {\ttfamily st} is a {\ttfamily \mbox{\hyperlink{classbenchmark_1_1State}{benchmark\+::\+State}}} object.

Unlike the {\ttfamily B\+E\+N\+C\+H\+M\+A\+RK} registration macros, which can only be used at the global scope, the {\ttfamily Register\+Benchmark} can be called anywhere. This allows for benchmark tests to be registered programmatically.

Additionally {\ttfamily Register\+Benchmark} allows any callable object to be registered as a benchmark. Including capturing lambdas and function objects.

For Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{auto BM\_test = [](benchmark::State\& st, auto Inputs) \{ /* ... */ \};}
\DoxyCodeLine{}
\DoxyCodeLine{int main(int argc, char** argv) \{}
\DoxyCodeLine{  for (auto\& test\_input : \{ /* ... */ \})}
\DoxyCodeLine{      benchmark::RegisterBenchmark(test\_input.name(), BM\_test, test\_input);}
\DoxyCodeLine{  benchmark::Initialize(\&argc, argv);}
\DoxyCodeLine{  benchmark::RunSpecifiedBenchmarks();}
\DoxyCodeLine{  benchmark::Shutdown();}
\DoxyCodeLine{\}}
\end{DoxyCode}


\label{_exiting-with-an-error}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md58}{}\doxysection{Exiting with an Error}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md58}
When errors caused by external influences, such as file I/O and network communication, occur within a benchmark the {\ttfamily State\+::\+Skip\+With\+Error(const char$\ast$ msg)} function can be used to skip that run of benchmark and report the error. Note that only future iterations of the {\ttfamily Keep\+Running()} are skipped. For the ranged-\/for version of the benchmark loop Users must explicitly exit the loop, otherwise all iterations will be performed. Users may explicitly return to exit the benchmark immediately.

The {\ttfamily Skip\+With\+Error(...)} function may be used at any point within the benchmark, including before and after the benchmark loop. Moreover, if {\ttfamily Skip\+With\+Error(...)} has been used, it is not required to reach the benchmark loop and one may return from the benchmark function early.

For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void BM\_test(benchmark::State\& state) \{}
\DoxyCodeLine{  auto resource = GetResource();}
\DoxyCodeLine{  if (!resource.good()) \{}
\DoxyCodeLine{    state.SkipWithError("Resource is not good!");}
\DoxyCodeLine{    // KeepRunning() loop will not be entered.}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  while (state.KeepRunning()) \{}
\DoxyCodeLine{    auto data = resource.read\_data();}
\DoxyCodeLine{    if (!resource.good()) \{}
\DoxyCodeLine{      state.SkipWithError("Failed to read data!");}
\DoxyCodeLine{      break; // Needed to skip the rest of the iteration.}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    do\_stuff(data);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{static void BM\_test\_ranged\_fo(benchmark::State \& state) \{}
\DoxyCodeLine{  auto resource = GetResource();}
\DoxyCodeLine{  if (!resource.good()) \{}
\DoxyCodeLine{    state.SkipWithError("Resource is not good!");}
\DoxyCodeLine{    return; // Early return is allowed when SkipWithError() has been used.}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{    auto data = resource.read\_data();}
\DoxyCodeLine{    if (!resource.good()) \{}
\DoxyCodeLine{      state.SkipWithError("Failed to read data!");}
\DoxyCodeLine{      break; // REQUIRED to prevent all further iterations.}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    do\_stuff(data);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\end{DoxyCode}


\label{_a-faster-keep-running-loop}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md59}{}\doxysection{A Faster Keep\+Running Loop}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md59}
In C++11 mode, a ranged-\/based for loop should be used in preference to the {\ttfamily Keep\+Running} loop for running the benchmarks. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{static void BM\_Fast(benchmark::State \&state) \{}
\DoxyCodeLine{  for (auto \_ : state) \{}
\DoxyCodeLine{    FastOperation();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{BENCHMARK(BM\_Fast);}
\end{DoxyCode}


The reason the ranged-\/for loop is faster than using {\ttfamily Keep\+Running}, is because {\ttfamily Keep\+Running} requires a memory load and store of the iteration count ever iteration, whereas the ranged-\/for variant is able to keep the iteration count in a register.

For example, an empty inner loop of using the ranged-\/based for method looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\# Loop Init}
\DoxyCodeLine{  mov rbx, qword ptr [r14 + 104]}
\DoxyCodeLine{  call benchmark::State::StartKeepRunning()}
\DoxyCodeLine{  test rbx, rbx}
\DoxyCodeLine{  je .LoopEnd}
\DoxyCodeLine{.LoopHeader: \# =>This Inner Loop Header: Depth=1}
\DoxyCodeLine{  add rbx, -\/1}
\DoxyCodeLine{  jne .LoopHeader}
\DoxyCodeLine{.LoopEnd:}
\end{DoxyCode}


Compared to an empty {\ttfamily Keep\+Running} loop, which looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{.LoopHeader: \# in Loop: Header=BB0\_3 Depth=1}
\DoxyCodeLine{  cmp byte ptr [rbx], 1}
\DoxyCodeLine{  jne .LoopInit}
\DoxyCodeLine{.LoopBody: \# =>This Inner Loop Header: Depth=1}
\DoxyCodeLine{  mov rax, qword ptr [rbx + 8]}
\DoxyCodeLine{  lea rcx, [rax + 1]}
\DoxyCodeLine{  mov qword ptr [rbx + 8], rcx}
\DoxyCodeLine{  cmp rax, qword ptr [rbx + 104]}
\DoxyCodeLine{  jb .LoopHeader}
\DoxyCodeLine{  jmp .LoopEnd}
\DoxyCodeLine{.LoopInit:}
\DoxyCodeLine{  mov rdi, rbx}
\DoxyCodeLine{  call benchmark::State::StartKeepRunning()}
\DoxyCodeLine{  jmp .LoopBody}
\DoxyCodeLine{.LoopEnd:}
\end{DoxyCode}


Unless C++03 compatibility is required, the ranged-\/for variant of writing the benchmark loop should be preferred.

\label{_disabling-cpu-frequency-scaling}%
\hypertarget{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md60}{}\doxysection{Disabling C\+P\+U Frequency Scaling}\label{md__home_mary_VegaProgramEngineering_2024_build__deps_googlebenchmark-src_docs_user_guide_autotoc_md60}
If you see this error\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{***WARNING*** CPU scaling is enabled, the benchmark real time measurements may be noisy and will incur extra overhead.}
\end{DoxyCode}


you might want to disable the C\+PU frequency scaling while running the benchmark\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{sudo cpupower frequency-\/set -\/-\/governor performance}
\DoxyCodeLine{./mybench}
\DoxyCodeLine{sudo cpupower frequency-\/set -\/-\/governor powersave}
\end{DoxyCode}
 